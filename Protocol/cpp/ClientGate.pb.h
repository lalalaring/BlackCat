// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientGate.proto

#ifndef PROTOBUF_ClientGate_2eproto__INCLUDED
#define PROTOBUF_ClientGate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ClientGate {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientGate_2eproto();
void protobuf_AssignDesc_ClientGate_2eproto();
void protobuf_ShutdownFile_ClientGate_2eproto();

class LoginRequest;
class BasicUserInfo;
class LoginResponse;

enum EnumLoginType {
  enumLoginTypeRegisterNewUser = 0,
  enumLoginTypeGuestAccount = 1,
  enumLoginTypeRegisterAccount = 2
};
bool EnumLoginType_IsValid(int value);
const EnumLoginType EnumLoginType_MIN = enumLoginTypeRegisterNewUser;
const EnumLoginType EnumLoginType_MAX = enumLoginTypeRegisterAccount;
const int EnumLoginType_ARRAYSIZE = EnumLoginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumLoginType_descriptor();
inline const ::std::string& EnumLoginType_Name(EnumLoginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumLoginType_descriptor(), value);
}
inline bool EnumLoginType_Parse(
    const ::std::string& name, EnumLoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumLoginType>(
    EnumLoginType_descriptor(), name, value);
}
enum EnumGender {
  enumGenderFemale = 0,
  enumGenderMale = 1,
  enumGenderUnknown = 2
};
bool EnumGender_IsValid(int value);
const EnumGender EnumGender_MIN = enumGenderFemale;
const EnumGender EnumGender_MAX = enumGenderUnknown;
const int EnumGender_ARRAYSIZE = EnumGender_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumGender_descriptor();
inline const ::std::string& EnumGender_Name(EnumGender value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumGender_descriptor(), value);
}
inline bool EnumGender_Parse(
    const ::std::string& name, EnumGender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumGender>(
    EnumGender_descriptor(), name, value);
}
enum EnumDeviceType {
  enumDeviceTypeiPhone = 0,
  enumDeviceTypeiPad = 1,
  enumDeviceTypeAndroid = 2,
  enumDeviceTypeWindows = 3
};
bool EnumDeviceType_IsValid(int value);
const EnumDeviceType EnumDeviceType_MIN = enumDeviceTypeiPhone;
const EnumDeviceType EnumDeviceType_MAX = enumDeviceTypeWindows;
const int EnumDeviceType_ARRAYSIZE = EnumDeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumDeviceType_descriptor();
inline const ::std::string& EnumDeviceType_Name(EnumDeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumDeviceType_descriptor(), value);
}
inline bool EnumDeviceType_Parse(
    const ::std::string& name, EnumDeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumDeviceType>(
    EnumDeviceType_descriptor(), name, value);
}
enum EnumResult {
  enumResultSucc = 0,
  enumResultFail = 1
};
bool EnumResult_IsValid(int value);
const EnumResult EnumResult_MIN = enumResultSucc;
const EnumResult EnumResult_MAX = enumResultFail;
const int EnumResult_ARRAYSIZE = EnumResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumResult_descriptor();
inline const ::std::string& EnumResult_Name(EnumResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumResult_descriptor(), value);
}
inline bool EnumResult_Parse(
    const ::std::string& name, EnumResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumResult>(
    EnumResult_descriptor(), name, value);
}
enum EnumNewVersion {
  enumUpdateTipNoNewVersion = 0,
  enumUpdateTipHasNewVersion = 1,
  enumUpdateTipHasNewVersionMandatoryUpdate = 2
};
bool EnumNewVersion_IsValid(int value);
const EnumNewVersion EnumNewVersion_MIN = enumUpdateTipNoNewVersion;
const EnumNewVersion EnumNewVersion_MAX = enumUpdateTipHasNewVersionMandatoryUpdate;
const int EnumNewVersion_ARRAYSIZE = EnumNewVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumNewVersion_descriptor();
inline const ::std::string& EnumNewVersion_Name(EnumNewVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumNewVersion_descriptor(), value);
}
inline bool EnumNewVersion_Parse(
    const ::std::string& name, EnumNewVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumNewVersion>(
    EnumNewVersion_descriptor(), name, value);
}
enum EnumVIPLevel {
  enumVIPLevelNone = 0,
  enumVIPLevelSilver = 1,
  enumVIPLevelGold = 2,
  enumVIPLevelPlatinum = 3,
  enumVIPLevelDiamond = 4
};
bool EnumVIPLevel_IsValid(int value);
const EnumVIPLevel EnumVIPLevel_MIN = enumVIPLevelNone;
const EnumVIPLevel EnumVIPLevel_MAX = enumVIPLevelDiamond;
const int EnumVIPLevel_ARRAYSIZE = EnumVIPLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumVIPLevel_descriptor();
inline const ::std::string& EnumVIPLevel_Name(EnumVIPLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumVIPLevel_descriptor(), value);
}
inline bool EnumVIPLevel_Parse(
    const ::std::string& name, EnumVIPLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumVIPLevel>(
    EnumVIPLevel_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ClientGate.EnumLoginType login_type = 1;
  inline bool has_login_type() const;
  inline void clear_login_type();
  static const int kLoginTypeFieldNumber = 1;
  inline ClientGate::EnumLoginType login_type() const;
  inline void set_login_type(ClientGate::EnumLoginType value);
  
  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // required string nick = 4;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 4;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  
  // required .ClientGate.EnumGender gender = 5;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 5;
  inline ClientGate::EnumGender gender() const;
  inline void set_gender(ClientGate::EnumGender value);
  
  // required .ClientGate.EnumDeviceType device_type = 6;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 6;
  inline ClientGate::EnumDeviceType device_type() const;
  inline void set_device_type(ClientGate::EnumDeviceType value);
  
  // required string device_id = 7;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 7;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  
  // optional string device_token = 8;
  inline bool has_device_token() const;
  inline void clear_device_token();
  static const int kDeviceTokenFieldNumber = 8;
  inline const ::std::string& device_token() const;
  inline void set_device_token(const ::std::string& value);
  inline void set_device_token(const char* value);
  inline void set_device_token(const char* value, size_t size);
  inline ::std::string* mutable_device_token();
  inline ::std::string* release_device_token();
  
  // required string mac = 9;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 9;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  
  // required string secure_key = 10;
  inline bool has_secure_key() const;
  inline void clear_secure_key();
  static const int kSecureKeyFieldNumber = 10;
  inline const ::std::string& secure_key() const;
  inline void set_secure_key(const ::std::string& value);
  inline void set_secure_key(const char* value);
  inline void set_secure_key(const char* value, size_t size);
  inline ::std::string* mutable_secure_key();
  inline ::std::string* release_secure_key();
  
  // required string channel = 11;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 11;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  
  // required uint32 version = 12;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 12;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // optional string phone_no = 13;
  inline bool has_phone_no() const;
  inline void clear_phone_no();
  static const int kPhoneNoFieldNumber = 13;
  inline const ::std::string& phone_no() const;
  inline void set_phone_no(const ::std::string& value);
  inline void set_phone_no(const char* value);
  inline void set_phone_no(const char* value, size_t size);
  inline ::std::string* mutable_phone_no();
  inline ::std::string* release_phone_no();
  
  // @@protoc_insertion_point(class_scope:ClientGate.LoginRequest)
 private:
  inline void set_has_login_type();
  inline void clear_has_login_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_device_token();
  inline void clear_has_device_token();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_secure_key();
  inline void clear_has_secure_key();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_phone_no();
  inline void clear_has_phone_no();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_;
  ::std::string* password_;
  int login_type_;
  int gender_;
  ::std::string* nick_;
  ::std::string* device_id_;
  ::std::string* device_token_;
  ::std::string* mac_;
  int device_type_;
  ::google::protobuf::uint32 version_;
  ::std::string* secure_key_;
  ::std::string* channel_;
  ::std::string* phone_no_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClientGate_2eproto();
  friend void protobuf_AssignDesc_ClientGate_2eproto();
  friend void protobuf_ShutdownFile_ClientGate_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class BasicUserInfo : public ::google::protobuf::Message {
 public:
  BasicUserInfo();
  virtual ~BasicUserInfo();
  
  BasicUserInfo(const BasicUserInfo& from);
  
  inline BasicUserInfo& operator=(const BasicUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicUserInfo& default_instance();
  
  void Swap(BasicUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  BasicUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicUserInfo& from);
  void MergeFrom(const BasicUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  
  // required string avatar = 3;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  
  // required .ClientGate.EnumGender gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 4;
  inline ClientGate::EnumGender gender() const;
  inline void set_gender(ClientGate::EnumGender value);
  
  // required int64 user_score = 5;
  inline bool has_user_score() const;
  inline void clear_user_score();
  static const int kUserScoreFieldNumber = 5;
  inline ::google::protobuf::int64 user_score() const;
  inline void set_user_score(::google::protobuf::int64 value);
  
  // required uint64 experience = 6;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 6;
  inline ::google::protobuf::uint64 experience() const;
  inline void set_experience(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:ClientGate.BasicUserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_user_score();
  inline void clear_has_user_score();
  inline void set_has_experience();
  inline void clear_has_experience();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_id_;
  ::std::string* nick_;
  ::std::string* avatar_;
  ::google::protobuf::int64 user_score_;
  ::google::protobuf::uint64 experience_;
  int gender_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClientGate_2eproto();
  friend void protobuf_AssignDesc_ClientGate_2eproto();
  friend void protobuf_ShutdownFile_ClientGate_2eproto();
  
  void InitAsDefaultInstance();
  static BasicUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ClientGate.EnumResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ClientGate::EnumResult result() const;
  inline void set_result(ClientGate::EnumResult value);
  
  // required .ClientGate.BasicUserInfo basic_user_info = 2;
  inline bool has_basic_user_info() const;
  inline void clear_basic_user_info();
  static const int kBasicUserInfoFieldNumber = 2;
  inline const ::ClientGate::BasicUserInfo& basic_user_info() const;
  inline ::ClientGate::BasicUserInfo* mutable_basic_user_info();
  inline ::ClientGate::BasicUserInfo* release_basic_user_info();
  
  // optional string update_url = 3;
  inline bool has_update_url() const;
  inline void clear_update_url();
  static const int kUpdateUrlFieldNumber = 3;
  inline const ::std::string& update_url() const;
  inline void set_update_url(const ::std::string& value);
  inline void set_update_url(const char* value);
  inline void set_update_url(const char* value, size_t size);
  inline ::std::string* mutable_update_url();
  inline ::std::string* release_update_url();
  
  // optional string ios_update_url = 4;
  inline bool has_ios_update_url() const;
  inline void clear_ios_update_url();
  static const int kIosUpdateUrlFieldNumber = 4;
  inline const ::std::string& ios_update_url() const;
  inline void set_ios_update_url(const ::std::string& value);
  inline void set_ios_update_url(const char* value);
  inline void set_ios_update_url(const char* value, size_t size);
  inline ::std::string* mutable_ios_update_url();
  inline ::std::string* release_ios_update_url();
  
  // optional string latest_version = 5;
  inline bool has_latest_version() const;
  inline void clear_latest_version();
  static const int kLatestVersionFieldNumber = 5;
  inline const ::std::string& latest_version() const;
  inline void set_latest_version(const ::std::string& value);
  inline void set_latest_version(const char* value);
  inline void set_latest_version(const char* value, size_t size);
  inline ::std::string* mutable_latest_version();
  inline ::std::string* release_latest_version();
  
  // optional string update_info = 6;
  inline bool has_update_info() const;
  inline void clear_update_info();
  static const int kUpdateInfoFieldNumber = 6;
  inline const ::std::string& update_info() const;
  inline void set_update_info(const ::std::string& value);
  inline void set_update_info(const char* value);
  inline void set_update_info(const char* value, size_t size);
  inline ::std::string* mutable_update_info();
  inline ::std::string* release_update_info();
  
  // @@protoc_insertion_point(class_scope:ClientGate.LoginResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_basic_user_info();
  inline void clear_has_basic_user_info();
  inline void set_has_update_url();
  inline void clear_has_update_url();
  inline void set_has_ios_update_url();
  inline void clear_has_ios_update_url();
  inline void set_has_latest_version();
  inline void clear_has_latest_version();
  inline void set_has_update_info();
  inline void clear_has_update_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ClientGate::BasicUserInfo* basic_user_info_;
  ::std::string* update_url_;
  ::std::string* ios_update_url_;
  ::std::string* latest_version_;
  ::std::string* update_info_;
  int result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClientGate_2eproto();
  friend void protobuf_AssignDesc_ClientGate_2eproto();
  friend void protobuf_ShutdownFile_ClientGate_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required .ClientGate.EnumLoginType login_type = 1;
inline bool LoginRequest::has_login_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_login_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_login_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_login_type() {
  login_type_ = 0;
  clear_has_login_type();
}
inline ClientGate::EnumLoginType LoginRequest::login_type() const {
  return static_cast< ClientGate::EnumLoginType >(login_type_);
}
inline void LoginRequest::set_login_type(ClientGate::EnumLoginType value) {
  GOOGLE_DCHECK(ClientGate::EnumLoginType_IsValid(value));
  set_has_login_type();
  login_type_ = value;
}

// required string account = 2;
inline bool LoginRequest::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginRequest::account() const {
  return *account_;
}
inline void LoginRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 3;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nick = 4;
inline bool LoginRequest::has_nick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_nick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_nick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& LoginRequest::nick() const {
  return *nick_;
}
inline void LoginRequest::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void LoginRequest::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void LoginRequest::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* LoginRequest::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .ClientGate.EnumGender gender = 5;
inline bool LoginRequest::has_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ClientGate::EnumGender LoginRequest::gender() const {
  return static_cast< ClientGate::EnumGender >(gender_);
}
inline void LoginRequest::set_gender(ClientGate::EnumGender value) {
  GOOGLE_DCHECK(ClientGate::EnumGender_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// required .ClientGate.EnumDeviceType device_type = 6;
inline bool LoginRequest::has_device_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::set_has_device_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequest::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequest::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ClientGate::EnumDeviceType LoginRequest::device_type() const {
  return static_cast< ClientGate::EnumDeviceType >(device_type_);
}
inline void LoginRequest::set_device_type(ClientGate::EnumDeviceType value) {
  GOOGLE_DCHECK(ClientGate::EnumDeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
}

// required string device_id = 7;
inline bool LoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& LoginRequest::device_id() const {
  return *device_id_;
}
inline void LoginRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* LoginRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string device_token = 8;
inline bool LoginRequest::has_device_token() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginRequest::set_has_device_token() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginRequest::clear_has_device_token() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginRequest::clear_device_token() {
  if (device_token_ != &::google::protobuf::internal::kEmptyString) {
    device_token_->clear();
  }
  clear_has_device_token();
}
inline const ::std::string& LoginRequest::device_token() const {
  return *device_token_;
}
inline void LoginRequest::set_device_token(const ::std::string& value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
}
inline void LoginRequest::set_device_token(const char* value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
}
inline void LoginRequest::set_device_token(const char* value, size_t size) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_device_token() {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    device_token_ = new ::std::string;
  }
  return device_token_;
}
inline ::std::string* LoginRequest::release_device_token() {
  clear_has_device_token();
  if (device_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_token_;
    device_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string mac = 9;
inline bool LoginRequest::has_mac() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginRequest::set_has_mac() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginRequest::clear_has_mac() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginRequest::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& LoginRequest::mac() const {
  return *mac_;
}
inline void LoginRequest::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void LoginRequest::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void LoginRequest::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* LoginRequest::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string secure_key = 10;
inline bool LoginRequest::has_secure_key() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginRequest::set_has_secure_key() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginRequest::clear_has_secure_key() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginRequest::clear_secure_key() {
  if (secure_key_ != &::google::protobuf::internal::kEmptyString) {
    secure_key_->clear();
  }
  clear_has_secure_key();
}
inline const ::std::string& LoginRequest::secure_key() const {
  return *secure_key_;
}
inline void LoginRequest::set_secure_key(const ::std::string& value) {
  set_has_secure_key();
  if (secure_key_ == &::google::protobuf::internal::kEmptyString) {
    secure_key_ = new ::std::string;
  }
  secure_key_->assign(value);
}
inline void LoginRequest::set_secure_key(const char* value) {
  set_has_secure_key();
  if (secure_key_ == &::google::protobuf::internal::kEmptyString) {
    secure_key_ = new ::std::string;
  }
  secure_key_->assign(value);
}
inline void LoginRequest::set_secure_key(const char* value, size_t size) {
  set_has_secure_key();
  if (secure_key_ == &::google::protobuf::internal::kEmptyString) {
    secure_key_ = new ::std::string;
  }
  secure_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_secure_key() {
  set_has_secure_key();
  if (secure_key_ == &::google::protobuf::internal::kEmptyString) {
    secure_key_ = new ::std::string;
  }
  return secure_key_;
}
inline ::std::string* LoginRequest::release_secure_key() {
  clear_has_secure_key();
  if (secure_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secure_key_;
    secure_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string channel = 11;
inline bool LoginRequest::has_channel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginRequest::set_has_channel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginRequest::clear_has_channel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginRequest::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& LoginRequest::channel() const {
  return *channel_;
}
inline void LoginRequest::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void LoginRequest::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void LoginRequest::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* LoginRequest::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 version = 12;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 LoginRequest::version() const {
  return version_;
}
inline void LoginRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional string phone_no = 13;
inline bool LoginRequest::has_phone_no() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginRequest::set_has_phone_no() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginRequest::clear_has_phone_no() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginRequest::clear_phone_no() {
  if (phone_no_ != &::google::protobuf::internal::kEmptyString) {
    phone_no_->clear();
  }
  clear_has_phone_no();
}
inline const ::std::string& LoginRequest::phone_no() const {
  return *phone_no_;
}
inline void LoginRequest::set_phone_no(const ::std::string& value) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::kEmptyString) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(value);
}
inline void LoginRequest::set_phone_no(const char* value) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::kEmptyString) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(value);
}
inline void LoginRequest::set_phone_no(const char* value, size_t size) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::kEmptyString) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_phone_no() {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::kEmptyString) {
    phone_no_ = new ::std::string;
  }
  return phone_no_;
}
inline ::std::string* LoginRequest::release_phone_no() {
  clear_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_no_;
    phone_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BasicUserInfo

// required string user_id = 1;
inline bool BasicUserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicUserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicUserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicUserInfo::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& BasicUserInfo::user_id() const {
  return *user_id_;
}
inline void BasicUserInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void BasicUserInfo::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void BasicUserInfo::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicUserInfo::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* BasicUserInfo::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string nick = 2;
inline bool BasicUserInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicUserInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicUserInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicUserInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& BasicUserInfo::nick() const {
  return *nick_;
}
inline void BasicUserInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void BasicUserInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void BasicUserInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicUserInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* BasicUserInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string avatar = 3;
inline bool BasicUserInfo::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicUserInfo::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicUserInfo::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicUserInfo::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& BasicUserInfo::avatar() const {
  return *avatar_;
}
inline void BasicUserInfo::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void BasicUserInfo::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void BasicUserInfo::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicUserInfo::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* BasicUserInfo::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .ClientGate.EnumGender gender = 4;
inline bool BasicUserInfo::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicUserInfo::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicUserInfo::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicUserInfo::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ClientGate::EnumGender BasicUserInfo::gender() const {
  return static_cast< ClientGate::EnumGender >(gender_);
}
inline void BasicUserInfo::set_gender(ClientGate::EnumGender value) {
  GOOGLE_DCHECK(ClientGate::EnumGender_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// required int64 user_score = 5;
inline bool BasicUserInfo::has_user_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasicUserInfo::set_has_user_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasicUserInfo::clear_has_user_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasicUserInfo::clear_user_score() {
  user_score_ = GOOGLE_LONGLONG(0);
  clear_has_user_score();
}
inline ::google::protobuf::int64 BasicUserInfo::user_score() const {
  return user_score_;
}
inline void BasicUserInfo::set_user_score(::google::protobuf::int64 value) {
  set_has_user_score();
  user_score_ = value;
}

// required uint64 experience = 6;
inline bool BasicUserInfo::has_experience() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicUserInfo::set_has_experience() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicUserInfo::clear_has_experience() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicUserInfo::clear_experience() {
  experience_ = GOOGLE_ULONGLONG(0);
  clear_has_experience();
}
inline ::google::protobuf::uint64 BasicUserInfo::experience() const {
  return experience_;
}
inline void BasicUserInfo::set_experience(::google::protobuf::uint64 value) {
  set_has_experience();
  experience_ = value;
}

// -------------------------------------------------------------------

// LoginResponse

// required .ClientGate.EnumResult result = 1;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ClientGate::EnumResult LoginResponse::result() const {
  return static_cast< ClientGate::EnumResult >(result_);
}
inline void LoginResponse::set_result(ClientGate::EnumResult value) {
  GOOGLE_DCHECK(ClientGate::EnumResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// required .ClientGate.BasicUserInfo basic_user_info = 2;
inline bool LoginResponse::has_basic_user_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_basic_user_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_basic_user_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_basic_user_info() {
  if (basic_user_info_ != NULL) basic_user_info_->::ClientGate::BasicUserInfo::Clear();
  clear_has_basic_user_info();
}
inline const ::ClientGate::BasicUserInfo& LoginResponse::basic_user_info() const {
  return basic_user_info_ != NULL ? *basic_user_info_ : *default_instance_->basic_user_info_;
}
inline ::ClientGate::BasicUserInfo* LoginResponse::mutable_basic_user_info() {
  set_has_basic_user_info();
  if (basic_user_info_ == NULL) basic_user_info_ = new ::ClientGate::BasicUserInfo;
  return basic_user_info_;
}
inline ::ClientGate::BasicUserInfo* LoginResponse::release_basic_user_info() {
  clear_has_basic_user_info();
  ::ClientGate::BasicUserInfo* temp = basic_user_info_;
  basic_user_info_ = NULL;
  return temp;
}

// optional string update_url = 3;
inline bool LoginResponse::has_update_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_update_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_update_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_update_url() {
  if (update_url_ != &::google::protobuf::internal::kEmptyString) {
    update_url_->clear();
  }
  clear_has_update_url();
}
inline const ::std::string& LoginResponse::update_url() const {
  return *update_url_;
}
inline void LoginResponse::set_update_url(const ::std::string& value) {
  set_has_update_url();
  if (update_url_ == &::google::protobuf::internal::kEmptyString) {
    update_url_ = new ::std::string;
  }
  update_url_->assign(value);
}
inline void LoginResponse::set_update_url(const char* value) {
  set_has_update_url();
  if (update_url_ == &::google::protobuf::internal::kEmptyString) {
    update_url_ = new ::std::string;
  }
  update_url_->assign(value);
}
inline void LoginResponse::set_update_url(const char* value, size_t size) {
  set_has_update_url();
  if (update_url_ == &::google::protobuf::internal::kEmptyString) {
    update_url_ = new ::std::string;
  }
  update_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_update_url() {
  set_has_update_url();
  if (update_url_ == &::google::protobuf::internal::kEmptyString) {
    update_url_ = new ::std::string;
  }
  return update_url_;
}
inline ::std::string* LoginResponse::release_update_url() {
  clear_has_update_url();
  if (update_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_url_;
    update_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ios_update_url = 4;
inline bool LoginResponse::has_ios_update_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_ios_update_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_ios_update_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_ios_update_url() {
  if (ios_update_url_ != &::google::protobuf::internal::kEmptyString) {
    ios_update_url_->clear();
  }
  clear_has_ios_update_url();
}
inline const ::std::string& LoginResponse::ios_update_url() const {
  return *ios_update_url_;
}
inline void LoginResponse::set_ios_update_url(const ::std::string& value) {
  set_has_ios_update_url();
  if (ios_update_url_ == &::google::protobuf::internal::kEmptyString) {
    ios_update_url_ = new ::std::string;
  }
  ios_update_url_->assign(value);
}
inline void LoginResponse::set_ios_update_url(const char* value) {
  set_has_ios_update_url();
  if (ios_update_url_ == &::google::protobuf::internal::kEmptyString) {
    ios_update_url_ = new ::std::string;
  }
  ios_update_url_->assign(value);
}
inline void LoginResponse::set_ios_update_url(const char* value, size_t size) {
  set_has_ios_update_url();
  if (ios_update_url_ == &::google::protobuf::internal::kEmptyString) {
    ios_update_url_ = new ::std::string;
  }
  ios_update_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_ios_update_url() {
  set_has_ios_update_url();
  if (ios_update_url_ == &::google::protobuf::internal::kEmptyString) {
    ios_update_url_ = new ::std::string;
  }
  return ios_update_url_;
}
inline ::std::string* LoginResponse::release_ios_update_url() {
  clear_has_ios_update_url();
  if (ios_update_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ios_update_url_;
    ios_update_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string latest_version = 5;
inline bool LoginResponse::has_latest_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_latest_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_latest_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_latest_version() {
  if (latest_version_ != &::google::protobuf::internal::kEmptyString) {
    latest_version_->clear();
  }
  clear_has_latest_version();
}
inline const ::std::string& LoginResponse::latest_version() const {
  return *latest_version_;
}
inline void LoginResponse::set_latest_version(const ::std::string& value) {
  set_has_latest_version();
  if (latest_version_ == &::google::protobuf::internal::kEmptyString) {
    latest_version_ = new ::std::string;
  }
  latest_version_->assign(value);
}
inline void LoginResponse::set_latest_version(const char* value) {
  set_has_latest_version();
  if (latest_version_ == &::google::protobuf::internal::kEmptyString) {
    latest_version_ = new ::std::string;
  }
  latest_version_->assign(value);
}
inline void LoginResponse::set_latest_version(const char* value, size_t size) {
  set_has_latest_version();
  if (latest_version_ == &::google::protobuf::internal::kEmptyString) {
    latest_version_ = new ::std::string;
  }
  latest_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_latest_version() {
  set_has_latest_version();
  if (latest_version_ == &::google::protobuf::internal::kEmptyString) {
    latest_version_ = new ::std::string;
  }
  return latest_version_;
}
inline ::std::string* LoginResponse::release_latest_version() {
  clear_has_latest_version();
  if (latest_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = latest_version_;
    latest_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string update_info = 6;
inline bool LoginResponse::has_update_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_update_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_update_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_update_info() {
  if (update_info_ != &::google::protobuf::internal::kEmptyString) {
    update_info_->clear();
  }
  clear_has_update_info();
}
inline const ::std::string& LoginResponse::update_info() const {
  return *update_info_;
}
inline void LoginResponse::set_update_info(const ::std::string& value) {
  set_has_update_info();
  if (update_info_ == &::google::protobuf::internal::kEmptyString) {
    update_info_ = new ::std::string;
  }
  update_info_->assign(value);
}
inline void LoginResponse::set_update_info(const char* value) {
  set_has_update_info();
  if (update_info_ == &::google::protobuf::internal::kEmptyString) {
    update_info_ = new ::std::string;
  }
  update_info_->assign(value);
}
inline void LoginResponse::set_update_info(const char* value, size_t size) {
  set_has_update_info();
  if (update_info_ == &::google::protobuf::internal::kEmptyString) {
    update_info_ = new ::std::string;
  }
  update_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_update_info() {
  set_has_update_info();
  if (update_info_ == &::google::protobuf::internal::kEmptyString) {
    update_info_ = new ::std::string;
  }
  return update_info_;
}
inline ::std::string* LoginResponse::release_update_info() {
  clear_has_update_info();
  if (update_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_info_;
    update_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClientGate

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumLoginType>() {
  return ClientGate::EnumLoginType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumGender>() {
  return ClientGate::EnumGender_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumDeviceType>() {
  return ClientGate::EnumDeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumResult>() {
  return ClientGate::EnumResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumNewVersion>() {
  return ClientGate::EnumNewVersion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ClientGate::EnumVIPLevel>() {
  return ClientGate::EnumVIPLevel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientGate_2eproto__INCLUDED
